#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.17
# In conjunction with Tcl version 8.6
#    Oct 02, 2018 12:11:05 PM CEST  platform: Linux
#    Oct 02, 2018 02:31:35 PM CEST  platform: Linux
#    Oct 02, 2018 03:31:38 PM CEST  platform: Linux
#    Oct 02, 2018 03:33:26 PM CEST  platform: Linux
#    Oct 02, 2018 04:36:15 PM CEST  platform: Linux
#    Oct 03, 2018 10:46:20 AM CEST  platform: Linux
#    Oct 03, 2018 02:49:40 PM CEST  platform: Linux
#    Oct 03, 2018 02:53:50 PM CEST  platform: Linux
#    Oct 04, 2018 11:28:39 AM CEST  platform: Linux
#    Oct 04, 2018 11:59:27 AM CEST  platform: Linux
#    Oct 04, 2018 02:01:37 PM CEST  platform: Linux
#    Oct 04, 2018 03:55:43 PM CEST  platform: Linux
#    Oct 04, 2018 09:43:21 PM CEST  platform: Linux
#    Oct 05, 2018 03:16:45 PM CEST  platform: Linux
#    Oct 07, 2018 08:02:53 PM CEST  platform: Linux
#    Oct 07, 2018 11:56:10 PM CEST  platform: Linux
#    Oct 08, 2018 10:57:13 AM CEST  platform: Linux
#    Oct 08, 2018 01:57:02 PM CEST  platform: Linux
#    Oct 08, 2018 03:31:30 PM CEST  platform: Linux
#    Oct 08, 2018 05:08:12 PM CEST  platform: Linux
#    Oct 09, 2018 09:52:04 AM CEST  platform: Linux
#    Oct 09, 2018 02:36:59 PM CEST  platform: Linux

import sys
from tkinter import filedialog
import matplotlib
matplotlib.use('TkAgg')
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg as FCTkAgg
from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
from matplotlib.figure import Figure
from matplotlib.pyplot import figure
import phase_sim
from parser_sim import parse_function, parse_x
from numpy import *
import codecs
import copy
import PSD
import datagenerator
import pathlib
from configparser import ConfigParser
from numpy import asarray as np_asarray


try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True


# Config files:
CONFIG_PATH = pathlib.Path.cwd() / 'configFiles'
LAST_ENTRY_NAME = 'last_entry.ini'
# End Config files

last_entry_conf = ConfigParser()
func_read = []
samples = int()

def set_Tk_var():
    global contEntry1,filename
    contEntry1 = StringVar()
    filename=StringVar()
    sys.stdout.flush()
    global cont_delim
    cont_delim = StringVar()
    global cont_chunck
    cont_chunck = StringVar()
    global eq_de
    eq_de = StringVar()
    global eq_te
    eq_te = StringVar()
    global eq_ph
    eq_ph = StringVar()
    global st_de
    st_de = StringVar()
    global point_num
    point_num = StringVar()
    global freq_cut
    freq_cut = StringVar()
    global freq_samp
    freq_samp = StringVar()
    global applyfilt
    applyfilt = IntVar(0)
    global upload_check
    upload_check = StringVar()
    global pow_value
    pow_value = StringVar()
    global applynoise
    applynoise = IntVar()
    global dataorig
    dataorig=1
    global dataorig_f
    dataorig_f=1
    global noiseenter
    noiseenter=0
    global filtenter
    filtenter=0
    global data_dir_load
    global issim
    global lo_mix
    lo_mix = IntVar(0)
    global freq_lo
    freq_lo = StringVar()

    global check_track
    check_track = StringVar()
    global downsamp
    downsamp = IntVar(0)
    global num_down
    num_down = StringVar()

    global rand_de
    rand_de = StringVar()
    global ck_rand_de
    ck_rand_de = IntVar(0)
    global rand_te
    rand_te = StringVar()
    global ck_rand_te
    ck_rand_te = IntVar(0)
    global rand_ph
    rand_ph = StringVar()
    global ck_rand_ph
    ck_rand_ph = IntVar(0)

    global in_de
    in_de = StringVar()
    global in_te
    in_te = StringVar()
    global in_ph
    in_ph = StringVar()



def phipsd_pressed(p1):
    psd00=PSD.plotpsd(f_ph,1/float(st_de.get()))
    f=figure()
    ax=f.add_subplot(111)
    ax.plot(psd00[0],psd00[1])
    locmaj = matplotlib.ticker.LogLocator(base=10,numticks=12)
    ax.xaxis.set_major_locator(locmaj)
    ax.loglog()
    ax.grid()
    ax.set_ylabel("Phase PSD (V^2/Hz)")
    ax.set_xlabel("freqeuncy (Hz)")
    f.show()
    sys.stdout.flush()
    f.show()
    sys.stdout.flush()

def psd_phi(p1):

    fs=get_freq()
    psd13=PSD.plotpsd(phil,fs)
    plotrefresh(pl13[0],pl13[1],psd13[0],psd13[1],1,ylab="PSD(rad^2/Hz)",xlab="frequency (Hz)")
    sys.stdout.flush()

def track_start(p1):
    global loaddata,phil
    check_track.set("Wait...")
    try :
        startp=[float(in_de.get()),float(in_te.get()),float(in_ph.get())]
        dell,thel,phil=phase_sim.tracker(loaddata,startp[0],startp[1],startp[2])
    except ValueError :
        dell,thel,phil=phase_sim.tracker(loaddata)
    tot=array([dell,thel,phil])
    plotrefresh(pl12[0],pl12[1],tot,col=["red","orange","green"],ylab="phase (rad)")
    check_track.set("Done...")
    if issim:
        plotrefresh(pl14[0],pl14[1],phil-f_ph,col="green",ylab="residual (rad)")

def LoadSim_pressed(p1):
    global w,loaddata,data_dir_load,issim,f_ph

    samples = int(point_num.get())

    parse_x(st_de.get(), samples)
    f_de = parse_function(eq_de.get())
    #parse_x(st_de.get(), samples)
    f_te = parse_function(eq_te.get())
    #parse_x(st_de.get(), samples)
    f_ph = parse_function(eq_ph.get())

    times_read=st_de.get()
    #fun_list=array([f_de[0],f_te[0],f_ph[0]])
    fun_list=array([f_de,f_te,f_ph])
    ck_list=[ck_rand_de.get(),ck_rand_te.get(),ck_rand_ph.get()]
    pow_list=[rand_de.get(),rand_te.get(),rand_ph.get()]
    myR=[]

    for n,i in enumerate(ck_list):
        if i:
           print("added noise")
           myR=datagenerator.RandomWalk(float(pow_list[n]),1/float(st_de.get()))
           myR.funrand(samples)
           fun_list[n]+=myR.randarr
           del myR

    func_read = [eq_de.get(), eq_te.get(), eq_ph.get()]


    last_x = parse_x(times_read,samples)
    last_func =[ parse_function(ff) for ff in func_read]

    plots=array(np_asarray(last_func))
    f_ph=fun_list[2]
    plotrefresh(pl1[0],pl1[1],fun_list,col=['r',"orange","green"],ylab="del,the,phi (rad)")
    loaddata=list(datagenerator.datagen(fun_list[0],fun_list[1],fun_list[2]))
    loaddata.insert(0,zeros(samples))
    loadata=array(loaddata)
    data_dir_load=1
    issim=1

    write_last(func_read,times_read,samples)


def Refresh_PSD(p1):


    loadpsd=empty_like(loaddata,dtype=float)
    if issim==0:
        loadpsd[1:5]=phase_sim.normalize(loaddata[1],loaddata[2],loaddata[3],loaddata[4])
    else:
        loadpsd=loaddata
    fs=get_freq()
    psd1=PSD.plotpsd(loadpsd[1],fs)
    print(len(psd1[0]))
    print(len(psd1[1]))
    plotrefresh(pl8[0],pl8[1],psd1[0],psd1[1],1,ylab="PSD(rad^2/Hz)",xlab="frequency (Hz)")
    psd2=PSD.plotpsd(loadpsd[2],fs)
    plotrefresh(pl9[0],pl9[1],psd2[0],psd2[1],1,ylab="PSD(rad^2/Hz)",xlab="frequency (Hz)")
    psd3=PSD.plotpsd(loadpsd[3],fs)
    plotrefresh(pl10[0],pl10[1],psd3[0],psd3[1],1,ylab="PSD(rad^2/Hz)",xlab="frequency (Hz)")
    psd4=PSD.plotpsd(loadpsd[4],fs)
    plotrefresh(pl11[0],pl11[1],psd4[0],psd4[1],1,ylab="PSD(rad^2/Hz)",xlab="frequency (Hz)")


def LoadFile_pressed(e):
    global w,loaddata,upload_check,data_dir_load,issim
    upload_check.set("Waiting...")
    w.Button3.config(relief=SUNKEN)
    del_decoded=codecs.decode(cont_delim.get(), 'unicode_escape')
    loaddata=array(phase_sim.loader(filename.get(),int(cont_chunck.get()),del_decoded))


    if lo_mix.get():
        loaddata[1:5]=phase_sim.downconvert(loaddata,float(freq_lo.get()))
    if downsamp.get():
        loaddata=array(phase_sim.downsampl(loaddata,int(num_down.get())))
    data_dir_load=1
    issim=0
    upload_check.set("Done!")



#    idea of the refresh button:
# the action  (filter and/or noise) is always applied to the data currently displayed
# except when no data is selected. In the latter case we come back to original data.
# When both the action are selected, the noise is applied before the filter
#

def Refresh_pressed(p1):
    global loaddata,loaddataprev,dataorig,dataorig_f,noiseenter,filtenter,data_dir_load

    if data_dir_load==1:
        try:
            loaddataprev=copy.copy(loaddata)
        except NameError:
            print("first data load")
        data_dir_load=0

   ##################################

    if applynoise.get():
        try:
            fss=get_freq()
            noiseenter=1
            if dataorig:
                loaddataprev=copy.copy(loaddata)
            loaddata[1:5]=phase_sim.whitenoise(loaddata[1:5],float(pow_value.get()),fss)
        except ValueError:
            print("data fsamp missing")
    else:
        try:
            if (not(filtenter) or noiseenter):
                loaddata=copy.copy(loaddataprev)
                dataorig=0
                noiseenter=0
                filtenter=0
        except NameError:
            print("noise not yet applied")

    if applyfilt.get():
        try:
            fss=get_freq()
            print("1")
            fcc=float(freq_cut.get())
            print("2")
            filtenter=1
            print("3")
            if dataorig_f:
                    print("4")
                    loaddataprev=copy.copy(loaddata)
            loaddata[1:5]=phase_sim.lowfilter(loaddata[1:5],fcc,fss)
            print("5")

        except ValueError:
            print("data fcut missing!")
    else:
        try:
            if not(noiseenter) :
                loaddata=copy.copy(loaddataprev)
                dataorig_f=0
                filtenter=0
        except NameError:
            print("filter not yet applied")

    plotrefresh(pl4[0],pl4[1],loaddata[1],ylab="ch1 (V)")
    plotrefresh(pl5[0],pl5[1],loaddata[2],ylab="ch2 (V)")
    plotrefresh(pl6[0],pl6[1],loaddata[3],ylab="ch3 (V)")
    plotrefresh(pl7[0],pl7[1],loaddata[4],ylab="ch4 (V)")



def Search_pressed(e):
    global filename
    name=filedialog.askopenfilename(initialdir=".")
    filename.set(name)
    w.Text1.insert(END,filename.get())
    sys.stdout.flush()


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    global pl1,pl4,pl5,pl6,pl7,pl8,pl9,pl10,pl11,pl12,pl13,pl14
    w = gui
    top_level = top
    root = top
    #top.wm_protocol('WM_DELETE_WINDOW',GUI_phase_support.on_closing())
    #params plot
    pl1=plotinit(w.Frame1)
    #channels plots
    pl4=plotinit(w.Frame4)
    pl5=plotinit(w.Frame5)
    pl6=plotinit(w.Frame6)
    pl7=plotinit(w.Frame7)
    #psd plots
    pl8=plotinit(w.Frame8,[0.15,0.2,0.75,0.75])
    pl9=plotinit(w.Frame9,[0.15,0.2,0.75,0.75])
    pl10=plotinit(w.Frame10,[0.15,0.2,0.75,0.75])
    pl11=plotinit(w.Frame11,[0.15,0.2,0.75,0.75])
    #recovery plots
    pl12=plotinit(w.Frame12)
    pl13=plotinit(w.Frame13,[0.15,0.2,0.75,0.75])
    pl14=plotinit(w.Frame14)
    on_load(last_entry_conf)


def on_load(last_entry_conf):
    if (CONFIG_PATH / LAST_ENTRY_NAME).exists():

        readed = read_last_entry(last_entry_conf)
        # equations


        eq_de.set(readed[0])
        eq_te.set(readed[1])
        eq_ph.set(readed[2])
        # Sampling times
        st_de.set(readed[3])
        # Sample number
        point_num.set(readed[4])


def plotinit(frameobj,p=[0,0,0,0]):
    global w
    f1=frameobj
    f= Figure()
    ax1= f.add_subplot(111)
    par=array(p)
    if (par!=0).all():
        ax1.set_position(p)

    canvas= FCTkAgg(f, f1)
    toolbar = NavigationToolbar2Tk(canvas, f1 )
    toolbar.pack()
    canvas.get_tk_widget().pack()
    return ax1, canvas

def plotrefresh(ax, canvasobj,x,y=None,logactive=0,col='b',ylab="yyy",xlab="xxx"):
    ax.clear()
    try: #check for y
        ax.plot(x,y)
    except ValueError: #check for multiple x
        if len(x.shape)>1:
            for n,i in enumerate(x): #multicolor plot
                ax.plot(i,col[n])
        else:
            ax.plot(x,color=col)
    if logactive:
        locmaj = matplotlib.ticker.LogLocator(base=10,numticks=12)
        ax.xaxis.set_major_locator(locmaj)
        ax.loglog()

    ax.grid()
    ax.set_ylabel(ylab)
    ax.set_xlabel(xlab)
    canvasobj.draw()

def destroy_window():
    # Function which closes the window.
    global top_level

    print("exiting")
    top_level.destroy()
    top_level = None

 # Write functions


def write_last(func_read,times_read,samples):
    print('GUI_phase_support.on_closing')
    #sys.stdout.flush()
    print(func_read,times_read,samples)


    # Let's create LAST_ENTRY_NAME file:
    conf_parser_obj = last_entry_conf

    if not CONFIG_PATH.exists():
        CONFIG_PATH.mkdir()

    if not (CONFIG_PATH / LAST_ENTRY_NAME).exists():
        create_last_entry(conf_parser_obj)

    update_last_entry(conf_parser_obj,func_read,times_read,samples)

def create_last_entry(conf_parser_obj):


    conf_parser_obj.add_section('EQUATIONS')
    conf_parser_obj.add_section('SAMPLING_TIMES')
    conf_parser_obj.add_section('N_SAMPLING')

def update_last_entry(conf_parser_obj,func_read,times_read,samples):
    print('toupdate')
    # Equations

    for i_eq_up in range(len(func_read)):
        conf_parser_obj.set('EQUATIONS','eq_' + str(i_eq_up+1), func_read[i_eq_up])

    # Sampling times
    conf_parser_obj.set('SAMPLING_TIMES', 'times', str(times_read))
    # Number of sampling
    conf_parser_obj.set('N_SAMPLING', 'num', str(samples))

    with open(str(CONFIG_PATH / LAST_ENTRY_NAME), 'w') as lastfile:
        conf_parser_obj.write(lastfile)

# Read functions


def read_last_entry(conf_parser_obj):
    eq = []
    times = []

    conf_parser_obj.read(CONFIG_PATH / LAST_ENTRY_NAME)
    #print(conf_parser_obj.sections())

    # Equations
    for i_eq_read in range(3):
        eq.append(conf_parser_obj.get('EQUATIONS','eq_' + str(i_eq_read+1)))
    # Sampling times
    times.append(conf_parser_obj.get('SAMPLING_TIMES', 'times'))
    # Number of sampling
    num = conf_parser_obj.get('N_SAMPLING', 'num')

    # Now I'll fill the Entries
    read_val = merge_arrays([eq,times,num])

    return read_val

def merge_arrays (list_of_lists):
    tmp_list = []
    for i_list in range(len(list_of_lists)):
        if  list == type(list_of_lists[i_list]):
            for el_sublist in range(len(list_of_lists[i_list])):
                tmp_list.append(list_of_lists[i_list][el_sublist])
        else:
            tmp_list.append(list_of_lists[i_list])
    return tmp_list


def get_freq():
    if issim:
        fs=1/float(st_de.get())
    else :
        try:
            fs=float(freq_samp.get())/int(num_down.get())
        except ValueError:
            fs=float(freq_samp.get())
    return fs


if __name__ == '__main__':
    import GUI_phase
    GUI_phase.vp_start_gui()
